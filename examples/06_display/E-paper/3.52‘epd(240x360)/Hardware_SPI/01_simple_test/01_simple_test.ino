#include <SPI.h>

#define EPD_BUSY_PIN          7
#define EPD_RESET_PIN         6
#define EPD_DC_PIN            5
#define EPD_CS_PIN            10  /* CS */
#define EPD_SCLK_PIN          12  /* CLK */
#define EPD_SDI_PIN           11  /* MOSI */
#define EPD_MISO_PIN          -1

#define EPD_WIDTH            240
#define EPD_HEIGHT           360

#define EPD_COLOR_WHITE       0xFF
#define EPD_COLOR_BLACK       0x00

unsigned long LUT_Flag = 0;
uint8_t BlackImage[((EPD_WIDTH % 8 == 0) ? (EPD_WIDTH / 8 ) : (EPD_WIDTH / 8 + 1)) * EPD_HEIGHT];


static const int spiClk = 25000000;
SPIClass * hspi = NULL;

const unsigned char  gImage3[] = {
/* Arial [未指定字号]*/
/*  3[0x0033]   96x32 */
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFC,0x0F,0xFF,0xFF,0xFF,0xF8,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x07,
0xFF,0xFF,0xFF,0xF0,0x01,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x07,0xFF,0xFF,0xFF,0xF0,
0x00,0x3F,0xFF,0xFF,0xFF,0xF0,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x0F,0xFF,0xFF,
0xFF,0xE0,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,0x07,0xFF,0xFF,0xFF,0xC0,0x3F,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFC,0x03,0xFF,0xFF,0xFF,0x80,0x7F,0xFF,0xFF,0xE0,0x1F,0xFF,
0xFE,0x01,0xFF,0xFF,0xFF,0x80,0x7F,0xFF,0xFF,0xF0,0x1F,0xFF,0xFE,0x01,0xFF,0xFF,
0xFF,0x80,0x7F,0xFF,0xFF,0xF0,0x1F,0xFF,0xFE,0x01,0xFF,0xFF,0xFF,0x80,0x7F,0xFF,
0xFF,0xF0,0x0F,0xFF,0xFC,0x03,0xFF,0xFF,0xFF,0xC0,0x3F,0xFF,0xFF,0xC0,0x03,0xFF,
0xF8,0x03,0xFF,0xFF,0xFF,0xE0,0x0F,0xFF,0xFF,0x80,0x00,0xFF,0xC0,0x07,0xFF,0xFF,
0xFF,0xF8,0x00,0xFF,0xF8,0x01,0x80,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFE,0x00,0x00,
0x00,0x03,0xE0,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x0F,0xFE,0x00,
0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,

};


//GCȫˢ
const unsigned char lut_R20_GC[] =
{
  0x01, 0x0f, 0x0f, 0x0f, 0x01, 0x01, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
const unsigned char lut_R21_GC[] =
{
  0x01, 0x4f, 0x8f, 0x0f, 0x01, 0x01, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
const unsigned char lut_R22_GC[] =
{
  0x01, 0x0f, 0x8f, 0x0f, 0x01, 0x01, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
const unsigned char lut_R23_GC[] =
{
  0x01, 0x4f, 0x8f, 0x4f, 0x01, 0x01, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
const unsigned char lut_R24_GC[] =
{
  0x01, 0x0f, 0x8f, 0x4f, 0x01, 0x01, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};


// DU ��ˢ
const unsigned char lut_R20_DU[] =
{
  0x01, 0x0f, 0x01, 0x00, 0x00, 0x01, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
const unsigned char lut_R21_DU[] =
{
  0x01, 0x0f, 0x01, 0x00, 0x00, 0x01, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
const unsigned char lut_R22_DU[] =
{
  0x01, 0x8f, 0x01, 0x00, 0x00, 0x01, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
const unsigned char lut_R23_DU[] =
{
  0x01, 0x4f, 0x01, 0x00, 0x00, 0x01, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
const unsigned char lut_R24_DU[] =
{
  0x01, 0x0f, 0x01, 0x00, 0x00, 0x01, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};


const unsigned char lut_vcom[] =
{
  0x01, 0x19, 0x19, 0x19, 0x19, 0x01, 0x01,
  0x01, 0x19, 0x19, 0x19, 0x01, 0x01, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_ww[] = {
  0x01, 0x59, 0x99, 0x59, 0x99, 0x01, 0x01,
  0x01, 0x59, 0x99, 0x19, 0x01, 0x01, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

};

const unsigned char lut_bw[] = {
  0x01, 0x59, 0x99, 0x59, 0x99, 0x01, 0x01,
  0x01, 0x59, 0x99, 0x19, 0x01, 0x01, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_wb[] = {

  0x01, 0x19, 0x99, 0x59, 0x99, 0x01, 0x01,
  0x01, 0x59, 0x99, 0x59, 0x01, 0x01, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_bb[] = {
  0x01, 0x19, 0x99, 0x59, 0x99, 0x01, 0x01,
  0x01, 0x59, 0x99, 0x59, 0x01, 0x01, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};


//LUT download
void lut_5S(void)
{
  unsigned int count;

  hspi->beginTransaction(SPISettings(spiClk, MSBFIRST, SPI_MODE0));
  digitalWrite(hspi->pinSS(), LOW); //pull SS slow to prep other end for transfer
  
  EPD_Write_Com(0x20);							//vcom
  for (count = 0; count < 56; count++)
  {
    EPD_Write_Data(lut_vcom[count]);
  }

  EPD_Write_Com(0x21);							//red not use
  for (count = 0; count < 42; count++)
  {
    EPD_Write_Data(lut_ww[count]);
  }

  EPD_Write_Com(0x24);							//wb w
  for (count = 0; count < 56; count++)
  {
    EPD_Write_Data(lut_bb[count]);
  }

  if (LUT_Flag == 0)
  {

    EPD_Write_Com(56);							//bb b
    for (count = 0; count < 80; count++)
    {
      EPD_Write_Data(lut_bw[count]);
    }


    EPD_Write_Com(0x23);							//bw r
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_wb[count]);
    }

    LUT_Flag = 1;
  }
  else
  {

    EPD_Write_Com(0x23);							//bb b
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_bw[count]);
    }


    EPD_Write_Com(0x22);							//bw r
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_wb[count]);
    }

    LUT_Flag = 0;
  }

  digitalWrite(hspi->pinSS(), HIGH); //pull ss high to signify end of data transfer
  hspi->endTransaction();

}


//LUT download
void lut_GC(void)
{
  unsigned int count;

  hspi->beginTransaction(SPISettings(spiClk, MSBFIRST, SPI_MODE0));
  digitalWrite(hspi->pinSS(), LOW); //pull SS slow to prep other end for transfer

  EPD_Write_Com(0x20);							//vcom
  for (count = 0; count < 56; count++)
  {
    EPD_Write_Data(lut_R20_GC[count]);
  }

  EPD_Write_Com(0x21);							//red not use
  for (count = 0; count < 42; count++)
  {
    EPD_Write_Data(lut_R21_GC[count]);
  }

  EPD_Write_Com(0x24);							//bb b
  for (count = 0; count < 56; count++)
  {
    EPD_Write_Data(lut_R24_GC[count]);
  }

  if (LUT_Flag == 0)
  {

    EPD_Write_Com(0x22);							//bw r
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_R22_GC[count]);
    }

    EPD_Write_Com(0x23);							//wb w
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_R23_GC[count]);
    }
    LUT_Flag = 1;
  }
  else
  {
    EPD_Write_Com(0x22);							//bw r
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_R23_GC[count]);
    }

    EPD_Write_Com(0x23);							//wb w
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_R22_GC[count]);
    }
    LUT_Flag = 0;
  }

  digitalWrite(hspi->pinSS(), HIGH); //pull ss high to signify end of data transfer
  hspi->endTransaction();

}


//LUT download
void lut_DU(void)
{
  unsigned int count;

  hspi->beginTransaction(SPISettings(spiClk, MSBFIRST, SPI_MODE0));
  digitalWrite(hspi->pinSS(), LOW); //pull SS slow to prep other end for transfer

  EPD_Write_Com(0x20);							//vcom
  for (count = 0; count < 56; count++)
  {
    EPD_Write_Data(lut_R20_DU[count]);
  }

  EPD_Write_Com(0x21);							//red not use
  for (count = 0; count < 42; count++)
  {
    EPD_Write_Data(lut_R21_DU[count]);
  }

  EPD_Write_Com(0x24);							//bb b
  for (count = 0; count < 56; count++)
  {
    EPD_Write_Data(lut_R24_DU[count]);
  }

  if (LUT_Flag == 0)
  {

    EPD_Write_Com(0x22);							//bw r
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_R22_DU[count]);
    }

    EPD_Write_Com(0x23);							//wb w
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_R23_DU[count]);
    }
    LUT_Flag = 1;
  }
  else
  {

    EPD_Write_Com(0x22);							//bw r
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_R23_DU[count]);
    }

    EPD_Write_Com(0x23);							//wb w
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_R22_DU[count]);
    }
    LUT_Flag = 0;
  }

  digitalWrite(hspi->pinSS(), HIGH); //pull ss high to signify end of data transfer
  hspi->endTransaction();
}


void EPD_display_buff(const unsigned char* picData)
{
  unsigned int i;

  hspi->beginTransaction(SPISettings(spiClk, MSBFIRST, SPI_MODE0));
  digitalWrite(hspi->pinSS(), LOW); //pull SS slow to prep other end for transfer

  EPD_Write_Com(0x13);		     //Transfer new data
  for (i = 0; i < (EPD_HEIGHT * EPD_WIDTH / 8); i++)
  {
    EPD_Write_Data(*picData);
    picData++;
  }

  digitalWrite(hspi->pinSS(), HIGH); //pull ss high to signify end of data transfer
  hspi->endTransaction();
}

void EPD_display_color(unsigned char color)
{
  unsigned int row, column;
  unsigned int pcnt;

  pcnt = 0;

  hspi->beginTransaction(SPISettings(spiClk, MSBFIRST, SPI_MODE0));
  digitalWrite(hspi->pinSS(), LOW); //pull SS slow to prep other end for transfer

  EPD_Write_Com(0x13);		     //Transfer new data

  for (column = 0; column < EPD_HEIGHT; column++)
  {
    for (row = 0; row < EPD_WIDTH / 8; row++)
    {
      EPD_Write_Data(color);
    }
  }

  digitalWrite(hspi->pinSS(), HIGH); //pull ss high to signify end of data transfer
  hspi->endTransaction();
}

void EPD_refresh(void)
{
  hspi->beginTransaction(SPISettings(spiClk, MSBFIRST, SPI_MODE0));
  digitalWrite(hspi->pinSS(), LOW); //pull SS slow to prep other end for transfer

  EPD_Write_Com(0x17);			//DISPLAY REFRESH
  EPD_Write_Data(0xA5);

  digitalWrite(hspi->pinSS(), HIGH); //pull ss high to signify end of data transfer
  hspi->endTransaction();

  lcd_chkstatus();
  delay(200);
}


void lcd_chkstatus(void)
{
  while (0 == digitalRead(EPD_BUSY_PIN))
    delay(200);
}


void EPD_sleep(void)
{
  hspi->beginTransaction(SPISettings(spiClk, MSBFIRST, SPI_MODE0));
  digitalWrite(hspi->pinSS(), LOW); //pull SS slow to prep other end for transfer

  EPD_Write_Com(0X07);    //deep sleep
  EPD_Write_Data(0xA5);

  digitalWrite(hspi->pinSS(), HIGH); //pull ss high to signify end of data transfer
  hspi->endTransaction();
}


void EPD_reset(void)
{
  digitalWrite(EPD_RESET_PIN, HIGH);
  delay(20);
  digitalWrite(EPD_RESET_PIN, LOW);
  delay(20);
  digitalWrite(EPD_RESET_PIN, HIGH);
  delay(20);
}


void EPD_Writ_Bus(unsigned char d)
{
  hspi->transfer(d);
}

void EPD_Write_Com(unsigned char VH)
{
  *(portOutputRegister(digitalPinToPort(EPD_DC_PIN))) &=  ~digitalPinToBitMask(EPD_DC_PIN);//EPD_RS=0;
  EPD_Writ_Bus(VH);
}

void EPD_Write_Data(unsigned char VH)
{
  *(portOutputRegister(digitalPinToPort(EPD_DC_PIN))) |=  digitalPinToBitMask(EPD_DC_PIN); //EPD_RS=1;
  EPD_Writ_Bus(VH);
}

void EPD_Write_Com_Data(unsigned char com, unsigned char dat)
{
  EPD_Write_Com(com);
  EPD_Write_Data(dat);
}


void SPI_Init(void)
{
  hspi = new SPIClass(HSPI);
  hspi->begin(EPD_SCLK_PIN, EPD_MISO_PIN, EPD_SDI_PIN, EPD_CS_PIN); //SCLK-14, MISO-12, MOSI-13, SS-15

  //set up slave select pins as outputs as the Arduino API
  //doesn't handle automatically pulling SS low
  pinMode(hspi->pinSS(), OUTPUT); //HSPI SS
}

void EPD_Init(void)
{
  hspi->beginTransaction(SPISettings(spiClk, MSBFIRST, SPI_MODE0));
  digitalWrite(hspi->pinSS(), LOW); //pull SS slow to prep other end for transfer  //CS

  LUT_Flag = 0;
#if 1  // 2022-5-22
  EPD_Write_Com(0x00);     // panel setting   PSR
  EPD_Write_Data(0xFF);      // RES1 RES0 REG KW/R     UD    SHL   SHD_N  RST_N
  EPD_Write_Data(0x01);      // x x x VCMZ TS_AUTO TIGE NORG VC_LUTZ

  EPD_Write_Com(0x01);     // POWER SETTING   PWR
  EPD_Write_Data(0x03);      //  x x x x x x VDS_EN VDG_EN
  EPD_Write_Data(0x10);      //  x x x VCOM_SLWE VGH[3:0]   VGH=20V, VGL=-20V
  EPD_Write_Data(0x3F);      //  x x VSH[5:0]  VSH = 15V
  EPD_Write_Data(0x3F);      //  x x VSL[5:0]  VSL=-15V
  EPD_Write_Data(0x03);      //  OPTEN VDHR[6:0]  VHDR=6.4V
  // T_VDS_OFF[1:0] 00=1 frame; 01=2 frame; 10=3 frame; 11=4 frame
  EPD_Write_Com(0x06);     // booster soft start   BTST
  EPD_Write_Data(0x37);      //  BT_PHA[7:0]
  EPD_Write_Data(0x3D);      //  BT_PHB[7:0]
  EPD_Write_Data(0x3D);      //  x x BT_PHC[5:0]

  EPD_Write_Com(0x60);     // TCON setting     TCON
  EPD_Write_Data(0x22);      // S2G[3:0] G2S[3:0]   non-overlap = 12

  EPD_Write_Com(0x82);     // VCOM_DC setting    VDCS
  EPD_Write_Data(0x07);      // x  VDCS[6:0] VCOM_DC value= -1.9v    00~3f,0x12=-1.9v

  EPD_Write_Com(0x30);
  EPD_Write_Data(0x09);

  EPD_Write_Com(0xe3);     // power saving     PWS
  EPD_Write_Data(0x88);      // VCOM_W[3:0] SD_W[3:0]

  EPD_Write_Com(0x61);     // resoultion setting
  EPD_Write_Data(0xf0);      //  HRES[7:3] 0 0 0
  EPD_Write_Data(0x01);      //  x x x x x x x VRES[8]
  EPD_Write_Data(0x68);      //  VRES[7:0]

  EPD_Write_Com(0X50);      //
  EPD_Write_Data(0xB7);     // Border

  delay(10);
#endif

  digitalWrite(hspi->pinSS(), HIGH); //pull ss high to signify end of data transfer
  hspi->endTransaction();
}


void setup()
{
  SPI_Init();

  pinMode(EPD_BUSY_PIN, OUTPUT);
  pinMode(EPD_RESET_PIN, OUTPUT);
  pinMode(EPD_DC_PIN, OUTPUT);

  digitalWrite(EPD_BUSY_PIN, HIGH);
  digitalWrite(EPD_RESET_PIN, HIGH);

  EPD_reset();
  EPD_Init();

}

void loop()
{

#if 1
  //EPD_reset();
  EPD_display_color(EPD_COLOR_WHITE);
  lut_GC();
  EPD_refresh();
  //EPD_sleep();
  delay(5000);
#else
  //EPD_reset();
  EPD_display_color(EPD_COLOR_BLACK);
  lut_GC();
  EPD_refresh();
  //EPD_sleep();
  delay(1000);
#endif

//EPD_partial_display_Full(0,64,gImage3,32,96,0);  //x,y,old_data,new_data,W,L,mode
}
