#define EPD_BUSY_PIN          7
#define EPD_RESET_PIN         6
#define EPD_DC_PIN            5
#define EPD_CS_PIN            10  /* CS */
#define EPD_SCLK_PIN          12  /* CLK */
#define EPD_SDI_PIN           11  /* MOSI */

#define EPD_HOR_RES           240
#define EPD_VER_RES           360

#define EPD_COLOR_WHITE       0xFF
#define EPD_COLOR_BLACK       0x00

unsigned long LUT_Flag = 0;
uint8_t BlackImage[((EPD_HOR_RES % 8 == 0) ? (EPD_HOR_RES / 8 ) : (EPD_HOR_RES / 8 + 1)) * EPD_VER_RES];


//GC全刷
const unsigned char lut_R20_GC[] = 
{
  0x01,0x0f,0x0f,0x0f,0x01,0x01,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};                
const unsigned char lut_R21_GC[] = 
{
  0x01,0x4f,0x8f,0x0f,0x01,0x01,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};             
const unsigned char lut_R22_GC[] = 
{
  0x01,0x0f,0x8f,0x0f,0x01,0x01,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
const unsigned char lut_R23_GC[] = 
{
  0x01,0x4f,0x8f,0x4f,0x01,0x01,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
const unsigned char lut_R24_GC[] = 
{
  0x01,0x0f,0x8f,0x4f,0x01,0x01,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};


// DU 局刷
const unsigned char lut_R20_DU[] = 
{
  0x01,0x0f,0x01,0x00,0x00,0x01,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};                
const unsigned char lut_R21_DU[] =   
{
  0x01,0x0f,0x01,0x00,0x00,0x01,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};             
const unsigned char lut_R22_DU[] = 
{
  0x01,0x8f,0x01,0x00,0x00,0x01,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
const unsigned char lut_R23_DU[] = 
{
  0x01,0x4f,0x01,0x00,0x00,0x01,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
const unsigned char lut_R24_DU[] = 
{
  0x01,0x0f,0x01,0x00,0x00,0x01,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};


const unsigned char lut_vcom[] =
{
  0x01,0x19,0x19,0x19,0x19,0x01,0x01,
  0x01,0x19,0x19,0x19,0x01,0x01,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

const unsigned char lut_ww[] ={
  0x01,0x59,0x99,0x59,0x99,0x01,0x01,
  0x01,0x59,0x99,0x19,0x01,0x01,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,

};

const unsigned char lut_bw[] ={
  0x01,0x59,0x99,0x59,0x99,0x01,0x01,
  0x01,0x59,0x99,0x19,0x01,0x01,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

const unsigned char lut_wb[] ={
  
  0x01,0x19,0x99,0x59,0x99,0x01,0x01,
  0x01,0x59,0x99,0x59,0x01,0x01,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

const unsigned char lut_bb[] ={
  0x01,0x19,0x99,0x59,0x99,0x01,0x01,
  0x01,0x59,0x99,0x59,0x01,0x01,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};


void EPD_Writ_Bus(unsigned char d)
{
  uint8_t val = 0x80;
  while (val)
  {
    if (d & val)
    {
      digitalWrite(EPD_SDI_PIN, HIGH);
    }
    else
    {
      digitalWrite(EPD_SDI_PIN, LOW);
    }
    digitalWrite(EPD_SCLK_PIN, LOW);
    digitalWrite(EPD_SCLK_PIN, HIGH);
    val >>= 1;
  }
}

void EPD_Write_Com(unsigned char VH)
{
  *(portOutputRegister(digitalPinToPort(EPD_DC_PIN))) &=  ~digitalPinToBitMask(EPD_DC_PIN);//LCD_RS=0;
  EPD_Writ_Bus(VH);
}

void EPD_Write_Data(unsigned char VH)
{
  *(portOutputRegister(digitalPinToPort(EPD_DC_PIN))) |=  digitalPinToBitMask(EPD_DC_PIN); //LCD_RS=1;
  EPD_Writ_Bus(VH);
}

void EPD_Write_Com_Data(unsigned char com, unsigned char dat)
{
  EPD_Write_Com(com);
  EPD_Write_Data(dat);
}


//LUT download
void lut_5S(void)
{
  unsigned int count;

  EPD_Write_Com(0x20);							//vcom
  for (count = 0; count < 56; count++)
  {
    EPD_Write_Data(lut_vcom[count]);
  }

  EPD_Write_Com(0x21);							//red not use
  for (count = 0; count < 42; count++)
  {
    EPD_Write_Data(lut_ww[count]);
  }

  EPD_Write_Com(0x24);							//wb w
  for (count = 0; count < 56; count++)
  {
    EPD_Write_Data(lut_bb[count]);
  }

  if (LUT_Flag == 0)
  {

    EPD_Write_Com(56);							//bb b
    for (count = 0; count < 80; count++)
    {
      EPD_Write_Data(lut_bw[count]);
    }


    EPD_Write_Com(0x23);							//bw r
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_wb[count]);
    }

    LUT_Flag = 1;
  }
  else
  {

    EPD_Write_Com(0x23);							//bb b
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_bw[count]);
    }


    EPD_Write_Com(0x22);							//bw r
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_wb[count]);
    }

    LUT_Flag = 0;
  }

}


//LUT download
void lut_GC(void)
{
  unsigned int count;

  EPD_Write_Com(0x20);							//vcom
  for (count = 0; count < 56; count++)
  {
    EPD_Write_Data(lut_R20_GC[count]);
  }

  EPD_Write_Com(0x21);							//red not use
  for (count = 0; count < 42; count++)
  {
    EPD_Write_Data(lut_R21_GC[count]);
  }

  EPD_Write_Com(0x24);							//bb b
  for (count = 0; count < 56; count++)
  {
    EPD_Write_Data(lut_R24_GC[count]);
  }

  if (LUT_Flag == 0)
  {

    EPD_Write_Com(0x22);							//bw r
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_R22_GC[count]);
    }

    EPD_Write_Com(0x23);							//wb w
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_R23_GC[count]);
    }
    LUT_Flag = 1;
  }
  else
  {
    EPD_Write_Com(0x22);							//bw r
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_R23_GC[count]);
    }

    EPD_Write_Com(0x23);							//wb w
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_R22_GC[count]);
    }
    LUT_Flag = 0;
  }

}


//LUT download
void lut_DU(void)
{
  unsigned int count;

  EPD_Write_Com(0x20);							//vcom
  for (count = 0; count < 56; count++)
  {
    EPD_Write_Data(lut_R20_DU[count]);
  }

  EPD_Write_Com(0x21);							//red not use
  for (count = 0; count < 42; count++)
  {
    EPD_Write_Data(lut_R21_DU[count]);
  }

  EPD_Write_Com(0x24);							//bb b
  for (count = 0; count < 56; count++)
  {
    EPD_Write_Data(lut_R24_DU[count]);
  }

  if (LUT_Flag == 0)
  {

    EPD_Write_Com(0x22);							//bw r
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_R22_DU[count]);
    }

    EPD_Write_Com(0x23);							//wb w
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_R23_DU[count]);
    }
    LUT_Flag = 1;
  }
  else
  {

    EPD_Write_Com(0x22);							//bw r
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_R23_DU[count]);
    }

    EPD_Write_Com(0x23);							//wb w
    for (count = 0; count < 56; count++)
    {
      EPD_Write_Data(lut_R22_DU[count]);
    }
    LUT_Flag = 0;
  }

}


void EPD_display_buff(const unsigned char* picData)
{
  unsigned int i;

  EPD_Write_Com(0x13);		     //Transfer new data
  for (i = 0; i < (EPD_VER_RES * EPD_HOR_RES / 8); i++)
  {
    EPD_Write_Data(*picData);
    picData++;
  }
}

void EPD_display_color(unsigned char color)
{
  unsigned int row, column;
  unsigned int pcnt;

  pcnt = 0;

  EPD_Write_Com(0x13);		     //Transfer new data

  for (column = 0; column < EPD_VER_RES; column++)
  {
    for (row = 0; row < EPD_HOR_RES / 8; row++)
    {
      EPD_Write_Data(color);
    }
  }
}

void EPD_refresh(void)
{
  EPD_Write_Com(0x17);			//DISPLAY REFRESH
  EPD_Write_Data(0xA5);
  lcd_chkstatus();
  delay(200);
}


void lcd_chkstatus(void)
{
  while (0 == digitalRead(EPD_BUSY_PIN))
    delay(200);
}


void EPD_sleep(void)
{
  EPD_Write_Com(0X07);    //deep sleep
  EPD_Write_Data(0xA5);
}


void EPD_reset(void)
{
  digitalWrite(EPD_RESET_PIN, HIGH);
  delay(20);
  digitalWrite(EPD_RESET_PIN, LOW);
  delay(20);
  digitalWrite(EPD_RESET_PIN, HIGH);
  delay(20);
}

void EPD_Init(void)
{

  LUT_Flag = 0;
#if 1  // 2022-5-22
  EPD_Write_Com(0x00);     // panel setting   PSR
  EPD_Write_Data(0xFF);      // RES1 RES0 REG KW/R     UD    SHL   SHD_N  RST_N
  EPD_Write_Data(0x01);      // x x x VCMZ TS_AUTO TIGE NORG VC_LUTZ

  EPD_Write_Com(0x01);     // POWER SETTING   PWR
  EPD_Write_Data(0x03);      //  x x x x x x VDS_EN VDG_EN
  EPD_Write_Data(0x10);      //  x x x VCOM_SLWE VGH[3:0]   VGH=20V, VGL=-20V
  EPD_Write_Data(0x3F);      //  x x VSH[5:0]  VSH = 15V
  EPD_Write_Data(0x3F);      //  x x VSL[5:0]  VSL=-15V
  EPD_Write_Data(0x03);      //  OPTEN VDHR[6:0]  VHDR=6.4V
  // T_VDS_OFF[1:0] 00=1 frame; 01=2 frame; 10=3 frame; 11=4 frame
  EPD_Write_Com(0x06);     // booster soft start   BTST
  EPD_Write_Data(0x37);      //  BT_PHA[7:0]
  EPD_Write_Data(0x3D);      //  BT_PHB[7:0]
  EPD_Write_Data(0x3D);      //  x x BT_PHC[5:0]

  EPD_Write_Com(0x60);     // TCON setting     TCON
  EPD_Write_Data(0x22);      // S2G[3:0] G2S[3:0]   non-overlap = 12

  EPD_Write_Com(0x82);     // VCOM_DC setting    VDCS
  EPD_Write_Data(0x07);      // x  VDCS[6:0] VCOM_DC value= -1.9v    00~3f,0x12=-1.9v

  EPD_Write_Com(0x30);
  EPD_Write_Data(0x09);

  EPD_Write_Com(0xe3);     // power saving     PWS
  EPD_Write_Data(0x88);      // VCOM_W[3:0] SD_W[3:0]

  EPD_Write_Com(0x61);     // resoultion setting
  EPD_Write_Data(0xf0);      //  HRES[7:3] 0 0 0
  EPD_Write_Data(0x01);      //  x x x x x x x VRES[8]
  EPD_Write_Data(0x68);      //  VRES[7:0]

  EPD_Write_Com(0X50);      //
  EPD_Write_Data(0xB7);     // Border

  delay(10);
#endif
}


void setup()
{
  pinMode(EPD_BUSY_PIN, OUTPUT);
  pinMode(EPD_RESET_PIN, OUTPUT);
  pinMode(EPD_SDI_PIN, OUTPUT);
  pinMode(EPD_SCLK_PIN, OUTPUT);
  pinMode(EPD_DC_PIN, OUTPUT);
  pinMode(EPD_CS_PIN, OUTPUT);

  digitalWrite(EPD_BUSY_PIN, HIGH);
  //digitalWrite(EPD_RESET_PIN, HIGH);

  EPD_reset();
  EPD_Init();

}

void loop()
{
#if 0
  EPD_reset();
  EPD_Init();
  EPD_display_color(EPD_COLOR_BLACK);
  lut_GC();
  EPD_refresh();
  //EPD_sleep();
  delay(1000);
#else
  EPD_reset();
  EPD_Init();
  EPD_display_color(EPD_COLOR_WHITE);
  lut_GC();
  EPD_refresh();
  //EPD_sleep();
  delay(1000);
#endif
}
